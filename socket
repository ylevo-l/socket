(function (window) {
    'use strict';
    console.log('v1.0.1');
    if (window.createChatInterceptor) return;

    class EventManager {
        constructor() {
            this.events = new Map();
        }
        subscribe(event, handler) {
            if (!this.events.has(event)) this.events.set(event, new Set());
            this.events.get(event).add(handler);
            return () => this.unsubscribe(event, handler);
        }
        unsubscribe(event, handler) {
            this.events.get(event)?.delete(handler);
        }
        dispatch(event, data) {
            this.events.get(event)?.forEach(handler => {
                try {
                    handler(data);
                } catch (err) {
                    console.error(`Error in "${event}" handler:`, err);
                }
            });
        }
    }

    class WebSocketInterceptor {
        constructor(dispatcher, filter) {
            this.dispatcher = dispatcher;
            this.filter = filter || '';
            this.activeConnections = new Set();
            this.originalWebSocket = window.WebSocket;
            this.overrideWebSocket();
        }
        overrideWebSocket() {
            const self = this, maxReconnect = 5;
            const wrapSocket = (url, protocols, attempt = 0) => {
                // Only allow one active connection per URL (and protocols).
                for (const conn of self.activeConnections) {
                    if (conn.url === url && conn.protocols === protocols && conn.instance.readyState !== self.originalWebSocket.CLOSED) {
                        return conn.instance;
                    }
                }
                const ws = protocols ? new self.originalWebSocket(url, protocols) : new self.originalWebSocket(url);
                const connection = { url, protocols, instance: ws, attempt };
                self.activeConnections.add(connection);
                ws.addEventListener('open', () => {
                    connection.attempt = 0;
                    self.dispatcher.dispatch('open', connection);
                });
                ws.addEventListener('message', event => {
                    self.dispatcher.dispatch('message', { connection, data: event.data });
                });
                ws.addEventListener('close', () => {
                    self.activeConnections.delete(connection);
                    self.dispatcher.dispatch('close', connection);
                    if (attempt < maxReconnect) {
                        setTimeout(() => wrapSocket(url, protocols, attempt + 1), Math.min(1000 * (2 ** attempt), 30000));
                    }
                });
                return ws;
            };
            window.WebSocket = (url, protocols) => {
                return (self.filter === '' || url.startsWith(self.filter))
                    ? wrapSocket(url, protocols)
                    : protocols
                        ? new self.originalWebSocket(url, protocols)
                        : new self.originalWebSocket(url);
            };
            window.WebSocket.prototype = this.originalWebSocket.prototype;
            Object.keys(this.originalWebSocket).forEach(key => {
                window.WebSocket[key] = this.originalWebSocket[key];
            });
            this.dispatcher.dispatch('init', null);
        }
        getActiveConnections() {
            return Array.from(this.activeConnections);
        }
    }

    function createChatInterceptor(options = {}) {
        const eventManager = new EventManager();
        const wsInterceptor = new WebSocketInterceptor(eventManager, options.wsFilter || '');
        eventManager.subscribe('message', ({ data }) => {
            try {
                const message = JSON.parse(data);
                if (message.event === 'App\\Events\\ChatMessageEvent' && message.data) {
                    const chat = JSON.parse(message.data);
                    eventManager.dispatch('chatMessage', chat);
                }
            } catch {}
        });
        return {
            onChatMessage: handler => eventManager.subscribe('chatMessage', handler),
            onMessage: handler => eventManager.subscribe('message', handler),
            onOpen: handler => eventManager.subscribe('open', handler),
            onClose: handler => eventManager.subscribe('close', handler),
            getActiveConnections: () => wsInterceptor.getActiveConnections()
        };
    }

    window.createChatInterceptor = createChatInterceptor;
})(window);
